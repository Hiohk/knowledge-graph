import{$ as a,U as i,S as l,av as s}from"./chunks/framework.DpMkwoNM.js";const t="/knowledge-graph/assets/image-10.DcPjdjhk.png",y=JSON.parse('{"title":"5. 异常","description":"","frontmatter":{"prev":{"text":"数组","link":"/backend/java/java04"},"next":{"text":"常用类","link":"/backend/java/java06"}},"headers":[],"relativePath":"backend/java/java05.md","filePath":"backend/java/java05.md","lastUpdated":1711810988000}'),e={name:"backend/java/java05.md"},n=s('<h1 id="_5-异常" tabindex="-1">5. 异常 <a class="header-anchor" href="#_5-异常" aria-label="Permalink to &quot;5. 异常&quot;">​</a></h1><h2 id="_5-1-异常概述" tabindex="-1">5.1 异常概述 <a class="header-anchor" href="#_5-1-异常概述" aria-label="Permalink to &quot;5.1 异常概述&quot;">​</a></h2><ol><li>什么是异常？有什么用？</li></ol><ul><li>Java 中的异常是指程序运行时出现了错误或异常情况，导致程序无法继续正常执行的现象。例如，数组下标越界、空指针异常、类型转换异常等都属于异常情况。</li><li>Java 提供了异常处理机制，即在程序中对可能出现的异常情况进行捕捉和处理。异常机制可以帮助程序员更好地管理程序的错误和异常情况，避免程序崩溃或出现不可预测的行为。</li><li>没有异常机制的话，程序中就可能会出现一些难以调试和预测的异常行为，可能导致程序崩溃，甚至可能造成数据损失或损害用户利益。因此，异常机制一项非常重要的功能，是编写可靠程序的基础。</li></ul><ol start="2"><li>异常在 Java 中以类和对象的形式存在。</li></ol><h2 id="_5-2-异常继承结构" tabindex="-1">5.2 异常继承结构 <a class="header-anchor" href="#_5-2-异常继承结构" aria-label="Permalink to &quot;5.2 异常继承结构&quot;">​</a></h2><ol><li>所有的异常和错误都是可抛出的。都继承了 Throwable 类。</li><li>Error 是无法处理的，出现后只有一个结果：JVM 终止。</li><li>Exception 是可以处理的。</li><li>Exception 的分类：</li></ol><ul><li>所有的 RuntimeException 的子类：运行时异常/未检查异常(UncheckedException)/非受控异常</li><li>Exception 的子类（除 RuntimeException 之外）：编译时异常/检查异常(CheckedException)/受控异常</li></ul><ol start="5"><li>编译时异常和运行时异常区别：</li></ol><ul><li>编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。</li><li>运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。</li><li>编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等</li><li>运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理</li></ul><p>注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new 异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。 <img src="'+t+`" alt="alt text" loading="lazy"></p><h2 id="_5-3-自定义异常" tabindex="-1">5.3 自定义异常 <a class="header-anchor" href="#_5-3-自定义异常" aria-label="Permalink to &quot;5.3 自定义异常&quot;">​</a></h2><ol><li>自定义异常 第一步：编写异常类继承 Exception/RuntimeException 第二步：提供一个无参数构造方法，再提供一个带 String msg 参数的构造方法，在构造方法中调用父类的构造方法。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span></code></pre></div><h2 id="_5-4-异常的处理" tabindex="-1">5.4 异常的处理 <a class="header-anchor" href="#_5-4-异常的处理" aria-label="Permalink to &quot;5.4 异常的处理&quot;">​</a></h2><h3 id="异常处理的两种方式" tabindex="-1">异常处理的两种方式 <a class="header-anchor" href="#异常处理的两种方式" aria-label="Permalink to &quot;异常处理的两种方式&quot;">​</a></h3><ol><li>声明异常：类似于推卸责任的处理方式</li></ol><p>在方法定义时使用 throws 关键字声明异常，告知调用者，调用这个方法可能会出现异常。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。 2. 捕捉异常：真正的处理捕捉异常</p><p>在可能出现异常的代码上使用 try..catch 进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。 3. 异常在处理的整个过程中应该是：声明和捕捉联合使用。 4. 什么时候捕捉？什么时候声明？</p><p>如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉。</p><h3 id="声明异常-throws关键字" tabindex="-1">声明异常 （throws关键字） <a class="header-anchor" href="#声明异常-throws关键字" aria-label="Permalink to &quot;声明异常 （throws关键字）&quot;">​</a></h3><ul><li>如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理） public void m() throws AException, BException... {}</li><li>如果AException和BException都继承了XException，那么也可以这样写： public void m() throws XException{}</li><li>调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。</li><li>如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。</li><li>发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。</li></ul><h3 id="捕捉异常-try-catch-关键字" tabindex="-1">捕捉异常 (try...catch...关键字) <a class="header-anchor" href="#捕捉异常-try-catch-关键字" aria-label="Permalink to &quot;捕捉异常 (try...catch...关键字)&quot;">​</a></h3><ul><li>如果一个异常发生后，不需要调用者知道，也不需要调用者来处理，选择使用捕捉方式处理。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 尝试执行可能会出现异常的代码</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果捕捉到AException类型的异常，在这里处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果捕捉到BException类型的异常，在这里处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(XException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果捕捉到XException类型的异常，在这里处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。</span></span></code></pre></div><ul><li>catch 可以写多个。并且遵循自上而下，从小到大。</li><li>Java7 新特性：catch 后面小括号中可以编写多个异常，使用运算符“|”隔开。</li></ul><h2 id="_5-5-异常的常用方法" tabindex="-1">5.5 异常的常用方法 <a class="header-anchor" href="#_5-5-异常的常用方法" aria-label="Permalink to &quot;5.5 异常的常用方法&quot;">​</a></h2><ol><li>获取异常的简单描述信息：</li></ol><ul><li><code>exception.getMessage()</code>;</li><li>获取的message是通过构造方法创建异常对象时传递过去的message。</li></ul><ol start="2"><li>打印异常堆栈信息：</li></ol><ul><li><code>exception.printStackTrace()</code>;</li></ul><ol start="3"><li>要会看异常的堆栈信息：</li></ol><ul><li>异常信息的打印是符合栈数据结构的。</li><li>看异常信息主要看最开始的描述信息。看栈顶信息。</li></ul><h2 id="_5-6-finally语句块" tabindex="-1">5.6 finally语句块 <a class="header-anchor" href="#_5-6-finally语句块" aria-label="Permalink to &quot;5.6 finally语句块&quot;">​</a></h2><ol><li>finally 语句块中的代码是一定会执行的。</li><li>finally 语句块不能单独使用，至少需要配合 try 语句块一起使用：</li></ol><ul><li><code>try...finally</code></li><li><code>try...catch...finally</code></li></ul><ol start="3"><li>通常在 finally 语句块中完成资源的释放</li></ol><ul><li>资源释放的工作比较重要，如果资源没有释放会一直占用内存。</li><li>为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行。</li><li>因此在finally语句块中通常进行资源的释放。</li></ul><ol start="4"><li>final、finally、finalize 分别是什么？</li></ol><ul><li>final 是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改。</li><li>finally 是一个关键字，和 try 一起使用，finally 语句块中的代码一定会执行。</li><li>finalize 是一个标识符，它是 Object 类中的一个方法名。</li></ul><h2 id="_5-7-方法覆盖与异常" tabindex="-1">5.7 方法覆盖与异常 <a class="header-anchor" href="#_5-7-方法覆盖与异常" aria-label="Permalink to &quot;5.7 方法覆盖与异常&quot;">​</a></h2><p>方法重写之后，不能比父类方法抛出更多的异常，可以更少。</p>`,43),h=[n];function o(p,c,r,d,k,u){return l(),i("div",null,h)}const g=a(e,[["render",o]]);export{y as __pageData,g as default};
