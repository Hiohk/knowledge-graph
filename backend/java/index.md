# Java

**符号说明**

* :white_check_mark: 需要学习者**掌握**的知识点；
* :heart: 高级开发者需要**重点掌握**的知识点；
* :rocket: 需要学习者**理解**的知识点；
* :star: 需要学习者**了解**的知识点；
* :x: 拓展知识点，可以不用学习；
# 1. 先导知识

## 1.1 常用的 windows 组合键

* win + D：回到桌面
* win + E：打开资源管理器
* win + R：打开运行窗口
* win + L：锁屏
* alt + tab：应用之间的切换

## 1.2 常用的 DOS 命令

### 打开 DOS 命令窗口

    win + R，输入 cmd，cmd 是 command 单词的缩写。

### 常用 DOS 命令：

* dir：列出当前路径下所有的文件以及目录。
* cls：clear screen 清屏。
* exit：退出 DOS 命令窗口。
* 切换盘符：c: 或者 d: 或者 e:
* del：删除一个文件或者多个文件。del Test.java del \*.java
* ipconfig 以及 ipconfig /all：查看网卡的相关信息，例如 ip 地址，mac 地址等。
  + ping 命令：查看两台计算机之间是否可以正常通信
  + ping 192.168.137.101
  + ping 192.168.137.101 -t
  + ping www.baidu.com
  + ping www.baidu.com -t
* 终止 DOS 命令窗口中某个命令的执行：ctrl + c
* mkdir：创建目录
* mkdir abc，表示在当前目录下新建一个目录：abc
* rd：删除目录
* rd abc，表示删除当前路径下的 abc 目录
* ren：重命名
* ren abc xyz，表示将当前路径下的 abc 目录名修改为 xyz
* cd 命令：
  + 作用是：切换目录。change directory
  + cd 命令的用法：cd 路径
  + 路径包括：
  + 相对路径：相对路径一定是相对于当前路径而言的，以当前路径为基准，从当前所在的位置开始找。
  + 绝对路径：在 windows 当中，路径开始的时候，是以盘符开始的，都是绝对路径。例如：C:\Users\Administrator\xyz\abc\def
  + cd .. 回到上级目录 （在 windows 系统中两个点.. 代表的是一个上级目录。扩展：其实还有一个路径叫做一个点 . 一个点代表的是当前路径。）
  + cd / 回到跟目录
  + 注意：路径在 windows 当中自动补全：使用 tab 键。
* 定时关机：
  shutdown -s -t 3600 一小时之后自动关机。
* 批处理文件
  my.bat 文件

```
cd C:\Users\Administrator\xyz\abc\def
c:
del *.java
```

作用：切换到 C:\Users\Administrator\xyz\abc\def 目录下，删除这个目录中所有的 java 文件。

### 通用的文本编辑快捷键

* ctrl+c 复制
* ctrl+v 粘贴
* ctrl+x 剪切
* ctrl+s 保存
* ctrl+z 撤销
* ctrl+y 重做
* ctrl+a 全选
* home 光标回到行首
* end 光标回到行尾
* ctrl + home 光标回到文章开始
* ctrl + end 光标回到文章末尾
* shift + home 或 end 选中一行
* 鼠标双击 （选中一个单词）
* ctrl + shift + 右箭头或左箭头 （选中一个单词）
* ctrl + f 查找

### java 中的注释

单行注释：

```
// 单行注释
// 单行注释
// 单行注释
// 单行注释
```

多行注释：

```
/*
	多行注释
	多行注释
*/
```

文档注释：

```
/**
* javadoc 注释，可以给 javadoc 命令解析提取并生成帮助文档
* @author dujubin
* @version 1.0
* @since 1.0
*/
```

使用以下命令可以提取生成帮助文档：

```
javadoc -d docs -author -version -encoding utf-8 HelloWorld.java
```

# 2. Java 基础语法

## 2.1 标识符

### 什么是标识符

1. 在 Java 中，标识符是用来给变量、方法、类和包等命名的字符序列。
2. 标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。

> 标识符标识符可以标识什么?
>
> 1. 变量名
>
> 2. 方法名
>
> 3. 类名、接口名、枚举名、注解名
>
> 4. 包名
>
> 5. 常量名
>
> ......

### 标识符命名规则

1. 标识符可以由字母、数字、下划线(\_)和美元符号($)组成，不能含有其他符号。（java 支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以）。

2. 标识符不能以数字开头。

3. 标识符不能是 Java 中的关键字，如 public、class、void 等。

4. 标识符是区分大小写的，即 Foo 和 foo 是两个不同的标识符。

5. 标识符的长度没有限制，但是 Java 建议使用有意义的、简短的标识符。

### 标识符命名规范

1. 见名知意

2. 驼峰式命名方式

3. 类名、接口名、枚举、注解：首字母大写，后面每个单词首字母大写。（StudentService，UserService）

4. 变量名和方法名：首字母小写，后面每个单词首字母大写。（doSome，doOther）

5. 常量名：全部大写，每个单词用下划线连接。（LOGIN_SUCCESS，SYSTEM_ERROR）

6. 包名：全部小写

## 2.2 关键字

### 什么是关键字

Java 关键字是 Java 编程语言中预定义的具有特殊含义的单词，这些单词不能被用作标识符，而是在语法中有特定的用法和限制。

### Java 关键字有哪些

1. Java 关键字都是小写的；
2. `abstract`, `assert`, `boolean`, `break`, `byte`, `case`, `catch`, `char`, `class`, `continue`, `default`, `do`, `double`, `else`, `enum`, `extends`, `final`, `finally`, `float`, `for`, `if`, `implements`, `import`, `instanceof`, `int`, `interface`, `long`, `native`, `new`, `package`, `private`, `protected`, `public`, `return`, `short`, `static`, `strictfp`, `super`, `switch`, `synchronized`, `this`, `throw`, `throws`, `transient`, `try`, `void`, `volatile`, `while`；
3. Java 保留字：`goto`，`const`。

## 2.3 字面量

### 什么是字面量

字面量指的是在程序中直接使用的数据，字面量是 Java 中最基本的表达式，不需要进行计算或转换，直接使用即可。

### Java 中有哪些字面量

* 整数型：10、-5、0、100
* 浮点型：3.14、-0.5、1.0
* 布尔型：true、false
* 字符型：'a'、'b'、'c'、'1'、'2'、'国'
* 字符串型："Hello"、"World"、"Java"、"你好呀"

## 2.4 变量

### 什么是变量？

1. 变量是内存当中的一块空间。是计算机中存储数据最基本的单元。
2. 变量三要素：
   - 数据类型（决定空间大小）【int, double, String】
   - 变量名（只要是合法的标识符即可）
   - 变量值（变量中具体存储的数据）
3. 变量的声明、赋值、访问
   - int i; //声明一个整数型的变量，起名
   - i = 100; //给变量 i 赋值 100
   - System.out.println(i); //访问 i 变量：读操作
   - i = 200; //访问 i 变量：改操作【给变量 i 重新赋值 200】

### 变量的作用

1. 变量的存在会让程序更加便于维护。

```java
System.out.println(100 + 111);
System.out.println(100 + 222);
// 以上代码的设计就不如以下的代码：
int num = 100;
System.out.println(num + 111);
System.out.println(num + 222);
```

2. 变量的存在可以增强程序的可读性。

```java
System.out.println(3.14 * 10 * 10);
// 以上代码的设计就不如以下的代码：
double π = 3.14;
int r = 10;
System.out.println(π * r * r);
```

::: tip 变量的小细节

1. 变量必须先声明，再赋值，才能访问;
2. 方法体当中的代码遵循自上而下的顺序依次逐行执行，变量先访问，再声明肯定是不行的;
3. 一行代码上可以同时声明多个变量;
4. 在同一个作用域当中，变量名不能重名，可以重新赋值;
5. 变量值的数据类型必须和变量的数据类型一致，这样是不允许的：`String name = 100`;
   :::

### 变量的作用域

* 作用域就是变量的有效范围。变量的作用域是怎样的呢？用一句大白话就可以概括了：出了大括号就不认识了。
* 作用域的不同主要是因为声明在不同位置的变量具有不同的生命周期。所谓的生命周期是：从内存开辟到内存释放。
* Java 遵循就近原则。

### 变量的分类

* 局部变量
* 成员变量
  + 静态变量
  + 实例变量

## 2.5 二进制、八进制与十六进制

### 二进制概述

计算机底层只能识别二进制。计算机底层只识别二进制是因为计算机内部的电子元件只能识别两种状态，即开和关，或者高电平和低电平。二进制正好可以用两
种状态来表示数字和字符，因此成为了计算机最基本的表示方法。在计算机内部，所有的数据都被转化为二进制形式进行处理和存储。虽然计算机可以通过不同的编程语言和程序来处理不同的数据类型和格式，但最终都需要将其转化为二进制形式才能被计算机底层识别和处理。

### 十进制与二进制的转换

十进制 -> 二进制：除 2 取余，一直到商为 0，最后将所有的余数逆序输出。
二进制 -> 十进制：每一位与权值相乘求和。

### 十进制与八进制的转换

略

### 十进制与十六进制转换

略

### 二进制与十六进制转换

略

## 2.6 原码反码补码

### byte 与 bit

* byte（字节）是计算机存储和处理数据的基本单位，通常由 8 个比特（bit）组成。每个比特是计算机中最小的存储单位，只能存储 0 或 1 两个状态。因此，一个字节可以存储 8 个比特的数据。
* 两者之间的关系是：1 byte = 8 bit，即 8 个比特（bit）组成一个字节（byte）。
* 在计算机中，数据通常以字节（byte）为单位进行存储和传输，而比特（bit）则是用来表示数据的最小单位。
* 1KB = 1024byte
* 1MB = 1024KB
* 1GB = 1024MB
* 1TB = 1024GB

### 原码、反码、补码

1. 原码、反码、补码是计算机二进制的三种表示形式；
2. 计算机在底层都是采用二进制补码形式表示的；
3. 二进制位最高位成为符号位，0 为正数，1 为负数。

### 正数的原码、反码、补码

1. 正数的原码、反码、补码是相同；
2. 请问正数 127 的原码、反码、补码分别是多少？（三者都是：0111 1111）

### 负数的原码、反码、补码

1. 负数的原码运算规则：将绝对值转化为二进制后，最高位改为 1；
2. -5 的原码：10000101；
3. -5 的反码：11111010；（原则是：**以原码作为参考，符号位不变，其他位取反**）
4. -5 的补码：11111011；（原则是：**以反码作为参考，符号位不变，加 1**）
5. 补码 -> 原码：补码最高位不变，其余取反加 1；
6. -128 的原码、反码、补码：
   - 原码：1000 0000
   - 反码：1111 1111
   - 补码：1000 0000

一个比特（1 bit）可以表示的数的范围：-128~127。

### 计算机底层为什么采用补码

1. 可以简化电路设计：采用补码形式可以将加减法运算转化为相同的操作，从而简化电路设计。
2. 解决了 0 的正负问题：在原码中，0 有两个表示，+0 和-0，这样会导致计算结果不唯一，而在补码中，0 只有一种表示，即全 0，可以避免这个问题。
3. 解决了负数溢出问题：在原码中，负数的表示范围比正数少 1，这样在进行减法运算时容易出现负数溢出的情况，而在补码中，负数的表示范围与正数相同，可以避免负数溢出的问题。
4. 方便计算机进行运算：补码形式可以方便计算机进行加减法运算，而且可以使用相同的电路进行运算，从而提高了计算机的运算效率。

## 2.7 数据类型 :white_check_mark:

### 基本数据类型

1. **整数型**

* byte: 小整数

* short: 中等大小整数

* int: Java 最常用的整数

* long: 极大或极小的整数 （BigInteger）

**自动类型转换**:

Java 中任何一个整数型字面量都会默认被当做 int 类型来处理。Java 中允许小容量的数据赋值给大容量的变量（自动类型转换）。取值容量排序：
`byte < short < int < long < float < double` 。

**强制类型转换**：

① Java 中大容量是无法直接转换成小容量的，因为这种操作可能会导致精度损失。

② 强制类型转换时，底层二进制是如何变化的？原则：砍掉左侧多余的二进制。

③ 强制类型转换时，精度可能会损失，也可能不会损失，这要看具体的数据是否真正的超出了强转后的类型的取值范围。

**byte 的赋值**:

① 在 Java 中有这样一个规定，当整数型字面量没有超出 byte 的范围：可以直接赋值给 byte 类型的变量。
`byte b = 127;` 这是允许的，很显然，这是一种编译优化。同时也是为了方便程序员写代码。

② 如果超出了范围，例如： `byte b = 128;` (编译报错)。这样就会报错，需要做强制类型转换，例如： `byte b = (byte)128;` （结果为-128）

③ 在整数类型中，除了 byte 有这个待遇之外， short 同样也是支持的。也就是说：如果整数型字面量没有超出 short 取值范围时，也是支持直接赋值的。

注：short 的赋值用法类似。

**两个 int 类型做运算**：

① 两个 int 类型的数据做运算，最终的结果还是 int 类型；

**多种数据类型混合运算**：

① 在 Java 中，多种数据类型混合运算时，各自先转换成容量最大的类型，再做运算

```java
byte a = 100;
int b = 200;
long c = 300L;
long d = a + b + c;
// 测试一下，如果 d 变量是 int 类型则编译器会报错
```

byte 和 short 混合运算的时候，各自先转换成 int 再做运算。

* `byte + byte ---> int`
* `byte + short ---> int`
* `short + short ---> int`

```java
short m = 10;
byte n = 10;
short result = m + n; // 编译器报错
int result = m + n; // 正确
```

2. **浮点型**

* float: 单精度，精度为 7 位小数

-double: 双精度，精度为 15 位小数，Java 中最常用的浮点类型。（BigDecimal）

**浮点型字面量默认被当做 double**：

* Java 中，浮点型字面量默认被当做 double 类型，如果要当做 float 类型，需要在数字后面添加 F 或 f。

```java
float f = 3.0; // 编译报错
// 报错原因是：3.0 默认被当做 double 类型，大容量无法直接赋值给小容量。可以修改为：
float f = 3.0F;
```

* double 精度高于 float：

```java
double d = 1.5656856894;
System.out.println(d); // 1.5656856894

float f = 1.5656856894F;
System.out.println(f); // 1.5656856
```

**浮点型数据两种表示形式**:

* 十进制

```java
double x = 1.23;
double y = 0.23;
double z = .23;
```

* 科学计数法

```java
double x = 0.123E2; // 0.123 * 10 的平方
double y = 123.34E-2; // 123.34 / 10 的平方
```

**浮点型数据存储原理**:star: ：

* 符号位：0 表示整数。1 表示负数。
* 指数位：比如小数 0.123E30，其中 30 就是指数。表示 0.123 \* 10 的 30 次幂。所以也有把指数位叫做偏移量的。最大偏移量 127。
* 尾数位：浮点数的小数部分的有效数字。例如：0.00123，那么尾数位存储 123 对应的二进制。
* 从浮点型数据存储原理上可以看到，二进制中的指数位决定了数字呈指数级增大。因此 float 虽然是 4 个字节，但却可以表示比 long 更大的数值。因此 float 容量比 long 的容量大。
  

![alt text](image.png)

**浮点型数据使用注意事项**：

一旦有浮点型数据参与运算得出的结果，一定不要使用“==”与其它数字进行“相等比较”

```java
// 不要这样使用
double x = 6.9;
double y = 3.0;
double z = x / y; // 2.3000000000000003
if(z == 2.3) {
    System.out.println("相等");
}
// 可以这样比较
double x = 6.9;
double y = 3.0;
double z = x / y;
if(z - 2.3 < 0.000001) {
    System.out.println("相等");
}
```

3. **布尔型**

* boolean: 主要用于逻辑判断

在 Java 中 boolean 类型只有两个值：true、false。没有其它值，没有 0 和 1 这一说。通常用于表示一些逻辑上的真假值，并在程序中进行逻辑控制，例如以下代码：

```java
boolean gender = true;
if(gender) {
    System.out.println("男");
} else {
    System.out.println("女");
}
```

4. **字符型**

* char: 单个字符

* 占用**两个字节**，取值范围：0 ~ 65535，和 short 容量相同，但 char 可以取更大的整数；
* 单个字符，使用单引号括起来，不能是多个字符；
* 可以保存一个汉字；
* `char c = '';` 这是不允许的；
* `char c = '\u0000';` 这表示一个**空字符**，也是 char 的默认值。`\u0000` 是一个 Unicode 码；(空格的 Unicode 码是 `\u0020`)
* 空字符与空格字符是不同的。空字符表示什么也没有。空格字符表示一个空格。

**转义字符**:

* `\t`: 表示制表符，相当于按下 Tab 键；
* `\n`: 表示换行符；
* `\"`: 表示双引号（"）；
* `\'`: 表示单引号（'）；
* `\\`: 表示反斜线（\）本身。

**字符编码**:

字符编码是人为规定的文字与二进制之间的转换关系。在早期计算机系统中，字符编码主要采用的是 ASCII 编码，采用 1 个字节编码。最多可以表示 256 个字符（实际上 ASCII 码表只用了 128 个），程序员需要记住这几个:

* a 对应 ASCII 码 97（b 是 98，...）
* A 对应 ASCII 码 65（B 是 66，...）
* 0 对应 ASCII 码 48（1 是 49，...）

**常见的字符编码**:star: :

* **ASCII 编码**（American Standard Code for Information Interchange：美国信息交换标准编码）：采用 1 个字节编码，包括字母、数字、符号和控制字符等。
* **Latin-1 编码**（ISO 8859-1），采用 1 个字节编码。该编码方式是为了表示欧洲语言（如荷兰语、西班牙语、法语、德语等）中的字符而设计的，共支持 256 个字符。
* **ANSI 编码**（American National Standards Institute：美国国家标准协会）：采用 1 个字节编码，支持英文、拉丁文等字符。两个 ANSI 码可以表示一个汉字。
* **Unicode 编码**：可表示所有语言的字符。采用了十六进制表示，占用 2 个字节或 4 个字节，最多可表示超过一百万个字符。（使用这种方式是有点浪费空间的，例如英文字符'a'其实采用一个字节存储就够了）[Unicode 在线转码工具](http://www.jsons.cn/unicode/)
* **UTF-8 编码**（Unicode Transformation Format，8-bit）：基于 Unicode 编码的可变长度字符编码，能够支持多语言和国际化的需求，使用 1~4 个字节来表示一个字符，是目前 Web 开发中最常用的字符编码方式。 （一个英文字母 1 个字节，一个汉字 3 个字节）
* **UTF-16 编码**：基于 Unicode 编码的可变长度字符编码，使用 2 或 4 个字节来表示一个字符，应用于很多较早的系统和编程语言中。 （一个英文字母 2 个字节。一个汉字 4 个字节。）
* **UTF-32 编码**：基于 Unicode 编码的固定长度字符编码，其特点是每个字符占用 4 个字节。
* **GB2312 编码（小）**：是中国国家标准的简体中文字符集，使用 2 个字节来表示一个汉字，是 GBK 编码的前身。
* **GBK 编码（Guo Biao Ku）（中）**：是针对中文设计的一个汉字编码方式，使用 2 个字节来表示一个汉字，能够表示中国内地的所有汉字。
* **GB18030 编码（大）**：是中国国家标准 GB 18030-2005《信息技术 中文编码字符集》中规定的字符集编码方案，用于取代 GB2312 和 GBK 编码。
* **Big5 编码（大五码）**：是台湾地区的繁体中文字符集，使用 2 个字节来表示一个汉字，适用于使用繁体中文的应用场景。

**char 参与的运算**:

Java 中允许将一个整数赋值给 char 类型变量，但这个整数会被当做 ASCII 码值来处理需要特别注意的是，这个码值有要求，不能超出 char 的取值范围。
只要没有超出 byte short char 的取值范围，是可以直接赋值给 byte short char 类型变量的。

```java
System.out.println('a' + 1); // 98
char c = 'a' + 1;
System.out.println(c); // b

// 以下程序结果是什么？
byte a = 1;
short b = 1;
char c = 1;
short num = a + b + c; // 编译器报错
```

注意，byte short char 混合运算时，各自会先转换成 int 再做运算!

| 数据类型 | 占用字节数 | 取值范围                           | 具体取值范围                               | 默认值   |
| -------- | ---------- | ---------------------------------- | ------------------------------------------ | -------- |
| byte     | 1          | -2^7 ~ 2^7-1                       | -128 ~ 127                                 | 0        |
| short    | 2          | -2^15 ~ 2^15-1                     | -32768 ~ 32767                             | 0        |
| int      | 4          | -2^31 ~ 2^31-1                     | -2147483648 ~ 2147483647                   | 0        |
| long     | 8          | -2^63 ~ 2^63-1                     | -9223372036854775808 ~ 9223372036854775807 | 0L       |
| float    | 4          | 1.4E-45 ~ 3.4028235E38             | 1.4E-45 ~ 3.4028235E38                     | 0.0f     |
| double   | 8          | 4.9E-324 ~ 1.79769313448623157E308 | 4.9E-324 ~ 1.79769313448623157E308         | 0.0d     |
| boolean  | 1          | true/false                         | true/false                                 | false    |
| char     | 2          | 0 ~ 2^16-1                         | 0 ~ 65535                                  | '\u0000' |

关于默认值： Java 语言中变量必须先声明，再赋值，才能使用。对于局部变量来说必须手动赋值，而对于成员变量来说，如果没有手动赋值，系统会自动赋默认值。

### 引用数据类型

类、接口、数组、枚举等

## 2.8 运算符 :white_check_mark:

概览：

* 算术运算符：+、-、\*、/、%、++、--
* 关系运算符：==、!=、>、>=、<、<=
* 逻辑运算符：&、|、!、&&、||
* 按位运算符：&、|、^、~、<<、>>、>>>
* 赋值运算符：=、+=、-=、\*=、/=、%=、&=、|=、^=、<<=、>>=、>>>=
* 条件运算符：?:
* instanceof 运算符：instanceof
* new 运算符：new
* . 运算符：.

### 算数运算符

* `+` ：求和、字符串拼接、正数
* `-` ：相减、负数
* `*` ：乘积
* `/` ：商（除法）
* `%` ：取模（求余数），取模公式：`x - x / y * y`
* `++` ：自加 1
* `--` ：自减 1

### 关系运算符

关系运算符又叫做比较运算符。包括： `>` 、 `>=` 、 `<` 、 `<=` 、 `==` 、 `!=` 。所有关系运算符的运算结果都是布尔类型，不是 true，就是 false。

```java
int a = 10;
int b = 10;
System.out.println(a > b); // false
System.out.println(a >= b); // true
System.out.println(a < b); // false
System.out.println(a <= b); // true
System.out.println(a == b); // true
System.out.println(a != b); // false
```

### 逻辑运算符

逻辑运算符：&（逻辑与）、 |（逻辑或）、 !（逻辑非）、^（逻辑异或）、 &&（短路与）、 ||（短路或）。

逻辑运算符特点：逻辑运算符两边的操作数要求必须是布尔类型，并且最终运算结果也一定是布尔类型。

* 逻辑与 &：两边操作数都是 true，结果才是 true。
* 逻辑或 |：两边操作数只要有一个是 true，结果就是true。
* 逻辑非 !： !false 就是 true，!true 就是 false。
* 逻辑异或 ^：咱俩不一样，结果就是 true。

* 短路与 &&：和逻辑与&的运算结果相同。只是存在一种短路现象。（左边操作数为 false 时，右边操作数不执行）
* 短路或 ||：和逻辑或|的运算结果相同。只是存在一种短路现象。（左边操作数为 true 时，右边操作数不执行）

虽然短路与 && 效率高于逻辑与 &，但逻辑与 & 也有用武之地，具体看需求是怎样的。

### 按位运算符

按位运算符用于在二进制位级别上处理整数数据。主要包括：
* 左移 <<
* 右移 >>
* 无符号右移 >>>
* 按位与 &
* 按位或 |
* 按位异或 ^
* 按位取反 ~

注意：按位运算符的操作数要求必须是整数。否则会出现编译错误

### 赋值运算符

### 条件运算符

### `instanceof` 运算符

### `new` 运算符

### `.` 运算符

## 2.9 控制语句 :white_check_mark:

## 2.10 方法 :white_check_mark:

## 2.11 package 和 import :white_check_mark:
