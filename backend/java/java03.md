---
prev:
  text: "Java 基础语法"
  link: "/backend/java/java02"

next:
  text: "数组"
  link: "/backend/java/java04"
---

# 3. 类和对象

## 3.1 面向对象概述

面向对象三大特征:

* 封装（Encapsulation）
* 继承（Inheritance）
* 多态（Polymorphism）

## 3.2 对象的创建和使用

### 语法格式

```java
[修饰符列表] class 类名 {
    // 属性（描述状态）
    // 方法（描述行为动作）
}
```

```java
public class Student {
    // 姓名
    String name; // 实例变量
    // 年龄
    int age;
    // 性别
    boolean gender;
    // 学习
    public void study() {
        System.out.println(“正在学习”);
    } // 实例方法
}
```

实例变量属于成员变量，成员变量如果没有手动赋值，系统会默认赋值：
| <div style="width:200px">数据类型</div> | <div style="width:300px">默认值</div> |
| :-------------------------------------: | :-----------------------------------: |
| byte | 0 |
| short | 0 |
| int | 0 |
| long | 0 |
| float | 0 |
| double | 0 |
| boolean | 0 |
| char | \u0000 |
| 引用数据类型 | null |

### 对象的创建和使用

```java
Student s = new Student();
```

在 Java 中，使用 class 定义的类，属于引用数据类型。所以 Student 属于引用数据类型。类型名为：Student。Student s; 表示定义一个变量。数据类型是 Student。变量名是 s。

对象的使用:

读取属性值：s.name

修改属性值：s.name = “jackson”; 

通过一个类可以实例化多个对象:

```java
Student s1 = new Student();
Student s2 = new Student();
```

### 对象的内存分析（对象与引用）

* new 运算符会在 JVM 的堆内存中分配空间用来存储实例变量。new 分配的空间就是 Java 对象。
* 在 JVM 中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。
* Java 中的 GC 主要针对的是 JVM 的堆内存。
* 空指针异常是如何发生的？
* 方法调用时参数是如何传递的？将变量中保存的值复制一份传递过去。
* 初次认识 this 关键字：出现在实例方法中，代表当前对象。“this.” 大部分情况下可以省略。
* this 存储在实例方法栈帧的局部变量表的 0 号槽位上。

## 3.3 封装

### 什么是封装？

封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。

### 封装的好处？

封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性，并提高了代码的可维护性和可复用性。

### 在代码上如何实现封装？

属性私有化，对外提供 getter 和 setter 方法。

## 3.4 构造方法

**构造方法有什么作用？**

* 构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。
* 在 Java 中，当我们使用关键字 new 时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。

**构造方法如何定义？**

[修饰符列表] 构造方法名(形参){}

构造方法名和类名一致。构造方法不需要提供返回值类型。

**构造方法如何调用？**

new 构造方法名(实参); 

构造方法执行结束后，会自动将创建的对象的内存地址返回（方法体内不需要写 return 语句）。

**关于无参数构造方法**：

如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。
构造方法支持重载机制。

**关于构造代码块**：

```java
{
    //...
}
```

构造代码块在 new 操作，先执行一次构造代码块。构造代码块在构造方法执行之前执行。

构造代码块的作用：如果所有的构造方法有相同的部分代码，可以将公共的代码提取到构造代码块中，便于代码复用。

**对象的创建和初始化过程**：

* new 的时候在堆内存中开辟空间，给所有属性赋默认值；
* 执行构造代码块进行初始化；
* 执行构造方法体进行初始化；
* 构造方法执行结束，对象初始化完毕。

## 3.5 this 关键字

* this 是一个关键字。
* this 出现在实例方法中，代表当前对象。语法是：this.
* **this 本质上是一个引用，该引用保存当前对象的内存地址**。
* 通过 `this.` 可以访问实例变量，可以调用实例方法。
* this 存储在栈帧的局部变量表的第 0 个槽位上。
* this. 大部分情况下可以省略，用于区分局部变量和实例变量时不能省略。
* this 不能出现在静态方法中。
* `this(实参)` 语法：
  + 只能出现在构造方法的第一行；
  + 通过当前构造方法去调用本类中其他的构造方法；
  + 作用：代码复用。

## 3.6 static 关键字

* static 是一个关键字，翻译为：静态的。
* static 修饰的变量叫做静态变量。当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。
* 静态变量在类加载时初始化，存储在堆中。
* static 修饰的方法叫做静态方法。
* 所有静态变量和静态方法，统一使用“类名.”调用。虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。
* 使用“引用.”访问静态相关的，即使引用为 null，也不会出现空指针异常。
* 静态方法中不能使用 this 关键字。因此无法直接访问实例变量和调用实例方法。
* 静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。
* 静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。

## 3.7 JVM 体系结构

## 3.8 单例模式

## 3.9 继承

## 3.10 方法覆盖

## 3.11 多态

## 3.12 super 关键字

## 3.13 final 关键字

## 3.14 抽象类

## 3.15 接口

## 3.16 类之间的关系

## 3.17 访问控制权限

## 3.18 Object 类

## 3.19 内部类
